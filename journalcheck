#!/bin/bash

#  journalcheck - Simple 'logcheck' replacement for journald
#  (C) 2015-2019 Alexander Koch

#  This software is released under the terms of the MIT License, see LICENSE.


FILTER_GLOBAL=${FILTER_GLOBAL:-"/usr/lib/journalcheck"}
FILTER_LOCAL=${FILTER_LOCAL:-~/".journalcheck.d"}
STATE_FILE=${STATE_FILE:-~/".journalcheck.state"}
NCPU=${NCPU:-$(grep -c '^processor' "/proc/cpuinfo")}
LOGLVL=${LOGLVL:-"0..5"}


# merge filters to single file
FILTER_FILE="$(mktemp)"
cat "$FILTER_GLOBAL"/*.ignore > "$FILTER_FILE"
if [ -d "$FILTER_LOCAL" ]; then
	for F in "$FILTER_LOCAL"/*.ignore; do
		cat "$F" >> "$FILTER_FILE"
	done
fi

# fetch journal entries since last run (or beginning of journal)
LOGF="$(mktemp)"
if [ -r "$STATE_FILE" ]; then
	journalctl --no-pager -a -p "$LOGLVL" --since="$(cat "$STATE_FILE")" > "$LOGF"
else
	journalctl --no-pager -a -p "$LOGLVL" -b > "$LOGF"
fi
date +'%F %T' > "$STATE_FILE"

# split journal into NCPU parts, spawn worker for each part
split -a 3 -n l/$NCPU -d "$LOGF" "${LOGF}_"
for I in $(seq 0 $(($NCPU - 1))); do
	IN="${LOGF}_$(printf "%03d" "$I")"
	OUT="${LOGF}_${I}_filtered"
	{ egrep -vf "$FILTER_FILE" "$IN" > "$OUT"; rm "$IN"; } &
done

# wait for all worker threads to finish
wait

# re-assemble filtered output to stdout, remove parts
for I in $(seq 0 $(($NCPU - 1))); do
	cat "${LOGF}_${I}_filtered"
	rm "${LOGF}_${I}_filtered"
done

rm -f "$FILTER_FILE" "$LOGF"

exit 0
